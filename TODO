nsh is a work in progress, future versions will be released which
implement much of the following (of course, diffs are welcome):

Cleanup:

* Finish up externs.h 
* Factor out common code, restructure, rewrite a few things after I have an
  idea of what the big picture looks like
* Check more errno values in various places for common mistakes and print out
  the error in "plain english" instead of kernel/library jargon
* More security auditing for string handling, off-by-one errors, and other
  problems
* User args should be set to lowercase at early so that we dont have to use
  strcasecmp/strncasecmp everywhere
* User args should be sanity checked early for crap
* Consistency in how we perror() for commands called from interface(),
  give user-friendly messages (but not from perror in conf() or other
  things that are not called direct from CLI)
* ...

Required for intended functionality:

* Finish 'save' command which will write routes, hostname, and the interface
  configurations to a file which can be read by cmdrc on
  startup with -i (requires the following to be done _first_:)
* Finish up interface mode handler commands
* Create pf commands under interface, generic mode handler:

* Allow simple block in all/pass out all keep state pf rules to be setup for
  interfaces (default modulate state?)
* Allow simple nat pf rules to be setup for interfaces
* Allow nat rdrs to be setup
* Allow pf holes to be setup
* Do we want a more sophisticated interface into pf or just let the user
  shell out to use pfctl?
* To handle pf on 'save' .... Only save rules that are simple enough to be
  represented by what we can setup for now.

Cute features:

* Perhaps some way for the shell to upgrade itself when given a network source
  for a new binary? 
* Hooks for a web interface? Does this even make sense?
* Add more diagnostic messages for verbose output where useful
* Can we hook into snmpd at all or just run it separately on the same box?
* Do we build in a simple ping, traceroute or just shell out for these??
* And what about telnet/ssh (maybe shell out for ssh and ignore telnet)??
* ALTQ RED/CBQ/HFSC
* Support for paging through displays of text X lines at a time
* Something comparable to "| inc" from cisco-land
* Tab command/argument completion
* Context-sensitive help
* Import unimplemented wicontrol features
* Convenient/automatic way to centralize configurations for tracking/revision
  control

Future:

* BGP, OSPF?? Hooks to integrate zebra(GPL)/gated(BSDlic)/mrtd(BSDlic)/???
* IPv6?? (shouldn't be hard, considering that most of the functions
  we stole from other source already support it)
* IPsec! Configure VPNs with simple CLI commands-isakmpd has a fifo interface
* IPComp...
* IPIP/GRE?? Other tunnels??
* IPX?? AppleTalk??

Known Bugs (or, things that I don't want to bother with right now, but
better not forget later...):

* Is it possible to properly implement a 'no nwid' command or should this be
  removed? (It currently does not work in nsh, anyways ifconfig cannot do
  this, and in any event the kernel does not appear to be able to remove
  this setting from a card!) Maybe we just set xyz.len=0 instead of the
  memset we do now?
* Need some kind of sanity checking for nwid variable, 'nwid ""' will cause
  some if_wi cards to stop responding properly.  Unsure of what is and isn't
  sane for various cards?????
* When 'no nwid' is used, a following 'show run' exposes other bugs in
  make_string()
* The 3.1 kernel does not keep count of information displayed in 'show rtstat'
  properly (what else??)
* We need to mask the rounding error for altq tbr 'rate' value

  The error can be demonstrated with the test program at
  ftp://nmedia.net/pub/nsh/tbrtest.c

  From Kenjiro Cho:
  "The rate is scaled by the clock frequency within the kernel.
  So, you see a rounding error when you set and get the rate.  

  When you set the rate, the internal rate is computed as:

        u_int64_t internal_rate = ((rate / 8) << 32) / clock_freq;

  When you get the rate, the rate is re-computed as:

        u_int rate = (internal_rate * 8 * clock_freq) >> 32;
 
  One way to mask the rounding error is to convert the value to a
  floating value, round off the mantissa, and convert it back to an
  integer."
* ...
